# setjmp補足

## ビルド、実行

クロス環境のバイナリの作成には、zigが便利という話をwebページで見つけたので、zigを使用している。

インストール: zigのwebページに書いてあった、ubuntu用パッケージのインストール方法に従っている。
```
$ snap install zig --classic --beta
```

ビルド:
```
$ zig cc -target riscv64-linux-musl jmp.c -o jmp
```

実行には、qemu-userを使用。

インストール:
```
$ sudo apt install qemu-user
```

実行:
```
$ qemu-riscv64 jmp
```

補足:  
もちろん、普通にgccでx86_64用のバイナリを作成しても、全く同様に動作する。
```
$ gcc -o jmp jmp.c
$ ./jmp
```

## アセンブルリスト

アセンブルリストの取得には、llvm-objdump を使用している。

インストール:
```
$ sudo apt install llvm
```

アセンブルリスト取得:
```
$ llvm-objdump -d jmp
```

setjmp/longjmp部分を以下に示す。
```
0000000001008da8 <longjmp>:
 1008da8: 00 61         ld      s0, 0(a0)
 1008daa: 04 65         ld      s1, 8(a0)
 1008dac: 03 39 05 01   ld      s2, 16(a0)
 1008db0: 83 39 85 01   ld      s3, 24(a0)
 1008db4: 03 3a 05 02   ld      s4, 32(a0)
 1008db8: 83 3a 85 02   ld      s5, 40(a0)
 1008dbc: 03 3b 05 03   ld      s6, 48(a0)
 1008dc0: 83 3b 85 03   ld      s7, 56(a0)
 1008dc4: 03 3c 05 04   ld      s8, 64(a0)
 1008dc8: 83 3c 85 04   ld      s9, 72(a0)
 1008dcc: 03 3d 05 05   ld      s10, 80(a0)
 1008dd0: 83 3d 85 05   ld      s11, 88(a0)
 1008dd4: 03 31 05 06   ld      sp, 96(a0)
 1008dd8: 83 30 85 06   ld      ra, 104(a0)
 1008ddc: 20 39         fld     fs0, 112(a0)
 1008dde: 24 3d         fld     fs1, 120(a0)
 1008de0: 07 39 05 08   fld     fs2, 128(a0)
 1008de4: 87 39 85 08   fld     fs3, 136(a0)
 1008de8: 07 3a 05 09   fld     fs4, 144(a0)
 1008dec: 87 3a 85 09   fld     fs5, 152(a0)
 1008df0: 07 3b 05 0a   fld     fs6, 160(a0)
 1008df4: 87 3b 85 0a   fld     fs7, 168(a0)
 1008df8: 07 3c 05 0b   fld     fs8, 176(a0)
 1008dfc: 87 3c 85 0b   fld     fs9, 184(a0)
 1008e00: 07 3d 05 0c   fld     fs10, 192(a0)
 1008e04: 87 3d 85 0c   fld     fs11, 200(a0)
 1008e08: 13 b5 15 00   seqz    a0, a1
 1008e0c: 2e 95         add     a0, a0, a1
 1008e0e: 82 80         ret

0000000001008e10 <setjmp>:
 1008e10: 00 e1         sd      s0, 0(a0)
 1008e12: 04 e5         sd      s1, 8(a0)
 1008e14: 23 38 25 01   sd      s2, 16(a0)
 1008e18: 23 3c 35 01   sd      s3, 24(a0)
 1008e1c: 23 30 45 03   sd      s4, 32(a0)
 1008e20: 23 34 55 03   sd      s5, 40(a0)
 1008e24: 23 38 65 03   sd      s6, 48(a0)
 1008e28: 23 3c 75 03   sd      s7, 56(a0)
 1008e2c: 23 30 85 05   sd      s8, 64(a0)
 1008e30: 23 34 95 05   sd      s9, 72(a0)
 1008e34: 23 38 a5 05   sd      s10, 80(a0)
 1008e38: 23 3c b5 05   sd      s11, 88(a0)
 1008e3c: 23 30 25 06   sd      sp, 96(a0)
 1008e40: 23 34 15 06   sd      ra, 104(a0)
 1008e44: 20 b9         fsd     fs0, 112(a0)
 1008e46: 24 bd         fsd     fs1, 120(a0)
 1008e48: 27 30 25 09   fsd     fs2, 128(a0)
 1008e4c: 27 34 35 09   fsd     fs3, 136(a0)
 1008e50: 27 38 45 09   fsd     fs4, 144(a0)
 1008e54: 27 3c 55 09   fsd     fs5, 152(a0)
 1008e58: 27 30 65 0b   fsd     fs6, 160(a0)
 1008e5c: 27 34 75 0b   fsd     fs7, 168(a0)
 1008e60: 27 38 85 0b   fsd     fs8, 176(a0)
 1008e64: 27 3c 95 0b   fsd     fs9, 184(a0)
 1008e68: 27 30 a5 0d   fsd     fs10, 192(a0)
 1008e6c: 27 34 b5 0d   fsd     fs11, 200(a0)
 1008e70: 01 45         li      a0, 0
 1008e72: 82 80         ret
```

RISC-Vを例に取ったのは、ブログ中で、RISC-Vを参照すると宣言した手前もあるが、riscv64-musl ライブラリの実装が、想定通りの単純な実装であったことが大きい。glibc x86_64版などでは、レジスタ保存以外にもいろいろごちゃごちゃやっていて、例に出すのがあまり適当ではなかったのである。おそらく、sigsetjumpとコード共通化して、シグナルマスクの処理などをしているようだった。純粋には、setjump/longjumの実装は、レジスタの退避、復元だけで良いはずである。

RISC-Vは、基本的には固定長であり、4バイトのはずであるが、所々、2バイトのところがある。これは、RVCと呼ばれるインストラクションセットである。別に使わなくてもよいが、コンパイラは積極的に使うようになっているようだ。RISC-Vの仕様書によると、RVCを使うことにより、25～30%ほどバイナリサイズを減らせると書いてあるがそんなものであろうか。(まあ、確かにllvm-objdumpの出力全体を見ると、結構、RVCの割合が多い気はする。)

アセンブルコードでは、命令のニーモニックそのものではなく、疑似命令を使っているところもある。上記に出ている中では、seqzとかretとかは疑似命令である。上記は、バイナリからアセンブルコードを生成しているが、llvm-objdumpは、できる部分は疑似命令を使うようになっているようだ。アセンブラでコーディングする際は疑似命令を使うことも多いと思われ、例えば、callも良く使う疑似命令であるが、llvm-objdumpでは、callは使わず、nativeのjalrを使用している。多分、関数名を特定するのが面倒であったのだろう。(なお、上記部分には、jalrの使用箇所はない)

バイナリコードも表示されているため、実際の命令が何か、仕様書と対照させて調べることができる。ここで注意しないといけないのが、RISC-Vがリトルエンディアンであることである。上記の「ld s0, 0(a0)」のバイナリは、「00 61」となっているが、仕様書と対照するときは、バイト列を反対にして「61 00」とした上で、2進「0110 0001 0000 0000」にする必要がある。これだから、リトルエンディアンは嫌いなんだよね。


