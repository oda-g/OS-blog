# シグナル処理補足

シグナル処理の実装に関する補足。現Linuxの実装に基づいた説明という訳ではなく、シグナル処理というものは大体こんな風な実装になっているはずという説明であることに注意。

割り込みはハードウェアの機構によって起きるものであったが、(割り込みを模した)シグナルは、OSの介在によって起きる。なお、OSは割り込み駆動(割り込みがないと動かない)であることは念頭に置いておこう。

![スレッド切り替えの様子](https://github.com/oda-g/OS-blog/blob/main/blog-diag/signal-handle.png)

ブログの[プログラム例(alarm.c)](https://github.com/oda-g/OS-blog/tree/main/signal/alarm.c)の場合、alarmシステムコールで設定した時間後にSIGALRMシグナルを送信するように仕掛けていた。シグナル送信の契機は、タイマ割り込みの延長の時限処理となる(①)。図は、プログラム(mainスレッド)実行中にタイマ割り込みが発生し、(alarm時間が過ぎていたので)シグナルが送信された様子を示している。なお、シグナル送信というのは、具体的にはプロセスの制御表にシグナルが送信されたという記録を付けることである。

シグナルハンドラの実行契機は、ユーザモードに復帰する時点となる。OSの動作としては、ユーザモード復帰時にシグナルを受信していた(かつブロックされていない)場合、シグナルハンドラを実行するということになっている。図の②では、本来、mainスレッドの割り込まれた地点に復帰するところであるが、シグナルを受信していたため、シグナルハンドラの実行を行う。何を実行するか(どのアドレスに飛ぶか)は、signalシステムコールで指定済である。本プログラム例では、スタックは、mainスレッドのものを使用する。シグナルハンドラ復帰後は、mainスレッド(の中断地点)に復帰するため、それで問題ない。別スタック使用の指示がされていれば、そのスタックを使用することになる。

さて、シグナルハンドラの実行はそれでよいとして、シグナルハンドラから復帰すると、元の中断地点に戻るのは、どうやっているのだろうか。それは、シグナルハンドラからの復帰用システムコール(Linuxでは、sigreturn)を使っている。OSは、シグナルハンドラ実行時のスタックに細工するなどして、シグナルハンドラ復帰時にsigreturnシステムコールを発行するような仕掛けを入れているのである。sigreturnシステムコールが発行され、OSに制御が移ると、OSは、mainスレッドの元々の割り込み地点に戻るようにして、ユーザモードに復帰させる(③)。

他のプロセスからシグナルを送信された場合(ex. killシステムコール)はどうであろうか。シグナル送信処理では、対象プロセスの制御表にシグナル送信の記録を付けるだけである。UP環境では、他のプロセスがシグナル送信処理を行っているということは、送られるプロセスは実行されていない。対象プロセスが実行可能状態であった場合は、プロセスがスケジューリングされ実行される(すなわち、ユーザモードに復帰する)時点でシグナル処理が行われることになる。対象プロセスが待ち状態であった場合は、シグナルを受信すると待ち状態を解除され、実行可能状態となる(⑤）。なお、待ち状態を解除されるとまずい場合もある(I/O完了待ちなど)ので、シグナル受け可能な待ち状態とシグナル受付不可の待ち状態が存在する。シグナル受付不可待ち状態でもシグナルは受信する(すぐに待ち状態が解除されないだけである)。待ち状態が解除されたプロセスは、ユーザモードに復帰する時点でシグナル処理が実行されることになる。

ブログでは、UP環境でも切り替え地点が制御できないマルチスレッド状態になることがあるケースとしてシグナルハンドラの紹介をした。本資料では、シグナルハンドラの実行について補足した。シグナル処理自体は、シグナルの種類により様々であり、また、シグナル受信のタイミングでも様々である。MP環境の場合は、別CPUで動作中のプロセスにシグナル送信を行ったケースなどの実装を考える必要があるだろう。本資料ではそこまでは踏み込まない。