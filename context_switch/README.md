# コンテキストスイッチコード補足

## ビルド、実行

残念ながら、setjumpで使用した、riscv64-musl ライブラリでは、getcontextがサポートされていなかったため、普通にx86_64 gcc を使用した。
```
$ gcc -o cswitch cswitch.c
$ ./cswitch
```

## ソースコード補足

### スレッド数
  
スレッド数を2としているが、NUM_THREADの値を変えれば、数を変えられる。

### スタックサイズ
  
プロダクトレベルのコードでは、きちんと最大値を見積もった上で設定するか、オーバフローしたときの対処を組み込む必要があるので注意。本コード中の10000は結構適当である。funcは、予想できる文字数でprintfを実行しているだけなので、きちんと見積ろうとすればできるはずではあるが。

### getcontext、setcontext、swapcontextの復帰値

まあ、大体エラーになることはないのであるが、manページに「エラー時には-1を返し、errnoを設定する」と書いてある以上は、-1が返ったときの処理を書かなければ、それは論理バグである。サンプルとしては、エラー処理を書かない方が分かり易いのであるが、そこは長年の習慣上外せない(※)。大体、OSのコードはエラー処理がほとんどであると言ってよい。エラー時にどうするか、その対処のロジックを考えるのが設計の肝と言ってよい(安易にパニックすれば良いというものではない)。なお、今回のコードは単純なサンプルなので、エラー発生時は、エラーメッセージを出力した上で速やかにプログラムを終了するようにしているだけである。

(※)きちんとエラーチェックしているかどうかが、プロか素人かの判断基準のひとつとなる。と言っておきながら、printfのエラーはチェックしていないが。まあ、そこまで面倒を見る必要はないという線引きは一応あったりする。

getcontextは、setjumpと異なり、最初の取得時もsetcontextによりresumeしたときも、復帰値が0で区別できない。区別するための方法はいろいろ考えられるが、swapcontextを使用すれば、その手間が省ける。swapcontextを使用する利点のひとつである。

### makecontext

makecontextが新しいスレッドを作成するためのポイントとなる関数。やっていることを簡単に言うと以下のとおり。

- getcontextで取得したコンテキストを引数で渡しているが、新しいコンテキストを作成するためのベースとして使用しているだけで、このコンテキストから再開させるという意図はない。
- スタックとして新しく確保したものを使用するようにする。(spの書き換え)
- setcontextされたときに、あたかもfuncの呼び出しが行われようとしている地点から再開される状態になるようレジスタの設定を行う。(rpや引数用レジスタの書き換え)
- funcから復帰したときに uc_link で設定したコンテキストに切り替わるような仕掛けを入れる。

### コードロジック補足

mainスレッドでfuncスレッドを作成し、最後にスケジューラ(sched)として働くという流れになっている。スケジュールすべきスレッドがなくなれば、プロセスは終了する。

スレッドのコンテキストは、FIFOのキューにつないで管理している。キューの操作を行う関数、put_sched_q(キューの最後につなぐ)、get_sched_q(キューの先頭から取り出す)を用意している。スケジューラは、先頭から取ってきて実行しているだけである。

スレッドの切り替えは、スレッド上で明示的に実行権を譲る(yeild)ことを契機に行われる。yeildでは、スレッドコンテキストをキューにつなぎ、swapcontextで自コンテキストの保存とschedコンテキストへの切り替えを行っている。

schedコンテキスト(con_sched)は、最初に一回取得(53行目)するだけで、以降、schedに切り替えられると毎回ここから再開する。makecontextでuc_linkにcon_schedを設定した時点では中身が入っていないが、参照する前に中身が埋まるので問題はない。

funcの処理終了時は、uc_linkの設定により、schedに切り替わる。スレッドコンテキストをキューにつないでいないので、funcが終了する度にキューにつながる数が減っていくことになる。funcがすべて終了すると、schedに切り替わったときにキューが空のため、schedが復帰し、プロセス終了することになる。

