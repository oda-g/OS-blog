# 仮想空間補足

## ビルド、実行

[setjump](https://github.com/oda-g/OS-blog/tree/main/setjmp)同様、RISC-V用バイナリを作成、実行。

```
$ zig cc -target riscv64-linux-musl addr.c -o addr
$ qemu-riscv64 addr
```

## アセンブルコード

llvm-objdumpで、コードの15行目「*((int *)0x10280a8) = 10;」がどうなっているのか見ると、以下のようになっている。

```
 10087c6: b7 85 02 01   lui     a1, 4136
 10087ca: 29 45         li      a0, 10
 10087cc: 23 a4 a5 0a   sw      a0, 168(a1)
```

C風に書くと以下のとおり。
```
a1 = 4136
a0 = 10
*(a1 << 12 + 168) = a0  ==>  *(4136 << 12 + 168) = 10  ==> 4136 << 12 + 168 == 16941224 == 0x10280a8
```

確かに0x10280a8番地に10をストアしている。

## RISC-Vの仮想空間(メモ)

括弧内の章番号は、仕様書(特権編)のもの。

ページングは、Sモード、Uモードで使用できる。Mモードでは使用できない。

仮想空間として、4タイプある。32bit用のSV32(4.3)、64bit用のSV39(4.4)、SV48(4.5)、SV57(4.6)。数字がそれぞれ、仮想空間の大きさ(bit数)を示している。

SV32は、ページテーブルエントリ(PTE)が4バイトであり、1ページあたりのエントリ数が1024。なので、ページテーブルの段数は丁度2段となる(32 = 10 + 10 + 12)。64bit用は、PTEが8バイトで、1ページ当たりのエントリ数が512。SV39、SV48、SV57は、丁度段数が3、4、5段になるようなビット数が選択されている(ex. 39 = 9 + 9 + 9 + 12)。物理の方は、物理ページ番号を示すフィールド長が、SV32が22ビット、SV39、SV48、SV57が44ビットとなっている。仮想アドレス空間と実アドレス空間の大きさをまとめると以下のとおり。

| |仮想|実|
|--|--|--|
|SV32|4GiB|16GiB|
|SV39|512GiB|64PiB|
|SV48|256TiB|64PiB|
|SV57|128PiB|64PiB|

PTEメモ:
- R/W/Xがall 0のとき、leafではないこと(i.e. 次段のページテーブルをポイント)を意味する。
- U: sstatusのSUM(4.1.1.2)の設定と合わせ、Uモードでアクセス可能だが、Sモードでアクセスできないという設定ができる。
- A/D: 2とおりのスキームが許されている(全hartで合わせる必要がある)。 <= プラットホームにより異なるということか
  - A/Dビットクリア時にread/writeがあると、ページフォルト例外。
  - A/Bビットクリア時にread/writeがあると、ビットを立てる。(Aの方は投機的実行でも立つ)
- V: PTEが有効かどうか
- G: PTEが全アドレススペース共用であることを示す。中間PTEにも設定可で、その場合は配下のPTEがグローバルであることを示す。アドレス変換キャッシュの処理(sfence.vma)に影響あり。
- RSW: 2ビット分、ソフトが自由に使えるフィールド。
- どの段のPTEもleafになれる。ex. SV39では、2MiBと1GiBのラージページ(仕様書では、superpageという用語を使用)を使用可能。

ページテーブルをポイントするコントロールレジスタは、stap (4.1.11)。以下のフィールドで構成されている。
- MODE: 仮想空間のタイプ(ex. SV39)。Bare(アドレス変換なし)も指定可能。
- ASID: 16bit。address space identifier。アドレス変換キャッシュの処理(sfence.vma)に影響。
- PPN: 最上段ページテーブルのphysical page number。

仕様書では、TLB(translation lookaside buffer)ではなく、アドレス変換キャッシュ(address translation cache)という用語を使っている。アドレス変換キャッシュの無効化には、sfence.vma命令(4.2.1)を使用する。fenceとあるように、これは、PTEのread/writeのorderをfenceするための命令であるが、同時にアドレス変換キャッシュの無効化も行う。sfence.vma命令では、ASID、仮想アドレスを指定でき、指定したASIDのみとか、指定した仮想アドレスのみを対象にすることができる。ASID指定の場合、G(グローバル)を指定された部分は適用されない。従来TLBといった場合に意味していた、仮想アドレスをキーとして物理アドレスを指していたキャッシュだけでなく、PTEアクセス時のキャッシュも含めて、アドレス変換キャッシュといているように思う。

ASIDは、16bit(32768)なので、ちょっと数が微妙ではあるが、同時に実行可能なプロセス数が32768以下で良ければ、プロセスごとに割り当てるのが便利そう。Linuxのプロセス空間構成では、プロセス共通で上位アドレス部分にカーネルが存在するが、そこでG(グローバル)指定をしておけば便利である。(仕様書を読んだ感想を述べているだけで、LinuxのRISC-Vアーキテクチャの実装を読んではいないので注意)
